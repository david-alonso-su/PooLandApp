@page "/"
@page "/mapview"
@using Microsoft.EntityFrameworkCore
@using PooLandApp.Data
@using BlazorLeaflet
@using BlazorLeaflet.Models
@using PooLandApp.Server
@using Radzen
@using Radzen.Blazor
@using Microsoft.Extensions.Options
@inject IJSRuntime jsRuntime
@inject PooLandDbContext pooContext
@inject IOptionsMonitor<LeafletOptions> leafletOptions
@inject IOptionsMonitor<DataOptions> dataOptions

@if (MapComponent == null)
{
    <RadzenProgressBar Value="100" ShowValue="false" Mode="ProgressBarMode.Indeterminate" />
}
else
{
    <div class="row" style="height:90vh;">
        <LeafletMap Map="MapComponent" />
    </div>
    <div class="row">
        <RadzenCard>
            <h4 class="mb-4">Weeks Ago From  @fromWeekAgoDisplay To @toWeekAgoDisplay</h4>
            <RadzenSlider Range="true" @bind-Value=@weeksAgo TValue="IEnumerable<int>" Min="@fromWeeksAgo" Max="0" Step=1 Change=@(args => OnChangeWeeksAgo(args)) Class="w-100" />
        </RadzenCard>
    </div>

}


@code {

    Map? MapComponent;

    IEnumerable<int>? weeksAgo;

    List<Poodatum>? PooData = new List<Poodatum>();
    List<Marker>? Markers = new List<Marker>();

    int fromWeeksAgo;

    int fromWeekAgoDisplay;
    int toWeekAgoDisplay;


    bool bOnChangeWeeksAgoFirst = true;

    protected override async Task OnInitializedAsync()
    {
        var MaxDaysAgo = dataOptions.CurrentValue.MaxDaysAgo;
        var DefaultStartDaysAgo = dataOptions.CurrentValue.DefaultStartDaysAgo;
        var DaysGrouping = dataOptions.CurrentValue.DaysGrouping;

        fromWeeksAgo = (int)Math.Round((double)-(MaxDaysAgo / DaysGrouping));
        var startWeekAgo = (int)Math.Round((double)-(DefaultStartDaysAgo / DaysGrouping));
        weeksAgo = new int[] { startWeekAgo, 0 };
        fromWeekAgoDisplay = Math.Abs(startWeekAgo);
        toWeekAgoDisplay = 0;

        PooData = await pooContext.Poodata.Where(x => x.Date > DateTime.UtcNow.AddDays(-MaxDaysAgo)).ToListAsync();


        var MaxBounsUp = new LatLng(leafletOptions.CurrentValue.MaxBounds.Up.Latitude, leafletOptions.CurrentValue.MaxBounds.Up.Longitude);
        var MaxBounsDown = new LatLng(leafletOptions.CurrentValue.MaxBounds.Down.Latitude, leafletOptions.CurrentValue.MaxBounds.Down.Longitude);

        MapComponent = new Map(jsRuntime)
            {

                Center = new LatLng(leafletOptions.CurrentValue.Center.Latitude, leafletOptions.CurrentValue.Center.Longitude),
                Zoom = leafletOptions.CurrentValue.Zoom,
                MaxBounds = new Tuple<LatLng, LatLng>(MaxBounsUp, MaxBounsDown)

            };

        MapComponent.OnInitialized += async () =>
        {
            MapComponent.AddLayer(new TileLayer
                {
                    UrlTemplate = leafletOptions.CurrentValue.UrlTemplate,
                    Attribution = leafletOptions.CurrentValue.Attribution
                });

        //MarkerCluster Not work on delete icons.
        //MapComponent.AddLayer(new MarkerClusterGroup());

        await LoadMarkers(PooData.Where(x => x.Date > DateTime.UtcNow.AddDays(-dataOptions.CurrentValue.DefaultStartDaysAgo)));

        };
    }

    async void OnChangeWeeksAgo(IEnumerable<int> value)
    {
        try
        {
            var listValues = value.ToList();
            var fromWeekAgo = listValues[0] * dataOptions.CurrentValue.DaysGrouping;
            var toWeekAgo = listValues[1] * dataOptions.CurrentValue.DaysGrouping;
            fromWeekAgoDisplay = Math.Abs(listValues[0]);
            toWeekAgoDisplay = Math.Abs(listValues[1]);
            Console.WriteLine($"From {fromWeekAgoDisplay} To {toWeekAgoDisplay}");
            await LoadMarkerWait(PooData.Where(x => x.Date > DateTime.UtcNow.AddDays(fromWeekAgo)
                                            && x.Date < DateTime.UtcNow.AddDays(toWeekAgo)));
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.ToString());
        }
    }

    async Task ClearMarkers()
    {
        lock (Markers)
        {
            foreach (var marker in Markers)
            {
                MapComponent.RemoveLayer(marker);
            }
            Markers.Clear();
        }
    }

    async Task LoadMarkerWait(IEnumerable<Poodatum> pooData, int waitTimeMs = 2000)
    {
        //Create this workArround because RadzenSlider fire every change in slider.
        await Task.Delay(waitTimeMs);
        if (bOnChangeWeeksAgoFirst)
        {
            bOnChangeWeeksAgoFirst = false;
            await LoadMarkers(pooData);
            bOnChangeWeeksAgoFirst = true;
        }
        else
        {
            Console.WriteLine("LoadMarkers Canceled");
        }
    }


    async Task LoadMarkers(IEnumerable<Poodatum> pooData)
    {
        Console.WriteLine($"Start Load markers From {fromWeekAgoDisplay} To {toWeekAgoDisplay} at {DateTime.UtcNow}");
        await ClearMarkers();
        List<Marker> tmpMarkers = new List<Marker>();

        await Parallel.ForEachAsync(pooData, async (poo, cancellationToken) =>
        {
            var marker = new Marker(poo.Latitude, poo.Longitude)
                {
                    Icon = new Icon
                    {
                        Url = "poo.png",
                        ClassName = "map-icon",
                    },
                    Popup = new Popup { Content = (new LeafletPopupLayout() { Description = poo.Description, Photo = poo.Photo }).GetHtml() },
                    Tooltip = new BlazorLeaflet.Models.Tooltip { Content = poo.Description },
                };
            MapComponent.AddLayer(marker);
            tmpMarkers.Add(marker);
        });

        lock (Markers)
        {
            Markers.AddRange(tmpMarkers);
        }
        Console.WriteLine($"End Load markers at {DateTime.UtcNow}");
    }
}
